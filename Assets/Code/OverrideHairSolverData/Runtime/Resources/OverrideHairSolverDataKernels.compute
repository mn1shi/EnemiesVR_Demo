#pragma kernel kOverrideParticlePositionsSolverData
#pragma kernel kOverrideParticlePositionsStaging

//#pragma enable_d3d11_debug_symbols
#define HAIRSIM_WRITEABLE_SOLVERDATA 1
#define HAIRSIM_WRITEABLE_SOLVERINPUT 0
#pragma multi_compile __ STAGING_COMPRESSION
// 0 == staging data full precision
// 1 == staging data compressed
#pragma multi_compile __ LAYOUT_INTERLEAVED
// 0 == particles grouped by strand, i.e. root, root+1, root, root+1
// 1 == particles grouped by index, i.e. root, root, root+1, root+1
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Assets/_Packages/com.unity.demoteam.hair/Runtime/HairSimData.hlsl"

ByteAddressBuffer _MeshPositions;
int3 _StrideOffsetMeshPositions;

float3 GetMeshPosition(uint i)
{
    return asfloat(_MeshPositions.Load3(i * _StrideOffsetMeshPositions.x + _StrideOffsetMeshPositions.y));
}

float3 GetMeshWorldPosition(uint i)
{
    return mul(_RootTransform, float4(GetMeshPosition(i), 1.f)).xyz;
}

[numthreads(64,1,1)]
void kOverrideParticlePositionsSolverData (uint id : SV_DispatchThreadID)
{
    uint srcVertexIndex = id;
    uint writeIndex = srcVertexIndex;
    
    float3 pos = GetMeshWorldPosition(srcVertexIndex);
    _ParticlePosition[writeIndex].xyz = pos;
}

//adapted from HairSimComputeSolver to produce roughly the same end result as subdivision from the real solver data. The main difference is that we don't care about the root, just take the mesh data as the truth truth
float3 CatmullRomPosition(float3 p0, float3 m0, float3 p1, float3 m1, float t)
{
    float tt = t * t;
    float ttt = t * tt;

    return
        p0 * (2 * ttt - 3 * tt + 1) +
        m0 * (ttt - 2 * tt + t) +
        p1 * (-2 * ttt + 3 * tt) +
        m1 * (ttt - tt);

}

#if LAYOUT_INTERLEAVED
#define DECLARE_STRAND_UNCHECKED(x)				\
const uint strandIndex = x;						\
const uint strandParticleBegin = strandIndex;	\
const uint strandParticleStride = _StrandCount;	\
const uint strandParticleEnd = strandParticleBegin + strandParticleStride * _StrandParticleCount;
#else
#define DECLARE_STRAND_UNCHECKED(x)										\
const uint strandIndex = x;												\
const uint strandParticleBegin = strandIndex * _StrandParticleCount;	\
const uint strandParticleStride = 1;									\
const uint strandParticleEnd = strandParticleBegin + strandParticleStride * _StrandParticleCount;
#endif

[numthreads(64,1,1)]
void kOverrideParticlePositionsStaging (uint id : SV_DispatchThreadID)
{
    DECLARE_STRAND_UNCHECKED(id);

    float3 p0 = GetMeshWorldPosition(strandParticleBegin).xyz;
    float3 p1 = GetMeshWorldPosition(strandParticleBegin + strandParticleStride).xyz;
    float3 m0 = p1 - p0;

    const uint segmentStepCount = _StagingSubdivision + 1;
    const float segmentStep = 1.0 / segmentStepCount;

    #if LAYOUT_INTERLEAVED
    uint writeIndex = strandIndex;
    uint writeStride = _StrandCount;
    #else
    uint writeIndex = strandIndex * _StagingVertexCount;
    uint writeStride = 1;
    #endif

    // segment 1..N-1
    for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd - strandParticleStride; i += strandParticleStride)
    {
        float3 p2 = GetMeshWorldPosition(i + strandParticleStride).xyz;
        float3 m1 = 0.5 * (p2 - p0);

        for (uint k = 0; k != segmentStepCount; k++, writeIndex += writeStride)
        {
            float3 x0_t = CatmullRomPosition(p0, m0, p1, m1, segmentStep * k);

            StoreStagingPosition(writeIndex, x0_t);
        }

        p0 = p1;
        p1 = p2;
        m0 = m1;
    }

    // segment N
    {
        float3 m1 = lerp(m0, p1 - p0, 2.0);

        for (uint k = 0; k != segmentStepCount; k++, writeIndex += writeStride)
        {
            float3 x0_t = CatmullRomPosition(p0, m0, p1, m1, segmentStep * k);

            StoreStagingPosition(writeIndex, x0_t);
        }

        p0 = p1;
        m0 = m1;
    }

    // cap
    StoreStagingPosition(writeIndex, p0);


}
