// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace ZivaRT
{

using global::System;
using global::System.Collections.Generic;
using global::FlatBuffers;

internal struct Network : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static Network GetRootAsNetwork(ByteBuffer _bb) { return GetRootAsNetwork(_bb, new Network()); }
  public static Network GetRootAsNetwork(ByteBuffer _bb, Network obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Network __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public ushort PoseIndices(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUshort(__p.__vector(o) + j * 2) : (ushort)0; }
  public int PoseIndicesLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<ushort> GetPoseIndicesBytes() { return __p.__vector_as_span<ushort>(4, 2); }
#else
  public ArraySegment<byte>? GetPoseIndicesBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public ushort[] GetPoseIndicesArray() { return __p.__vector_as_array<ushort>(4); }
  public float PoseShift(int j) { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(__p.__vector(o) + j * 4) : (float)0; }
  public int PoseShiftLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<float> GetPoseShiftBytes() { return __p.__vector_as_span<float>(6, 4); }
#else
  public ArraySegment<byte>? GetPoseShiftBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public float[] GetPoseShiftArray() { return __p.__vector_as_array<float>(6); }
  public float PoseScale(int j) { int o = __p.__offset(8); return o != 0 ? __p.bb.GetFloat(__p.__vector(o) + j * 4) : (float)0; }
  public int PoseScaleLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<float> GetPoseScaleBytes() { return __p.__vector_as_span<float>(8, 4); }
#else
  public ArraySegment<byte>? GetPoseScaleBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public float[] GetPoseScaleArray() { return __p.__vector_as_array<float>(8); }
  public float KernelScale(int j) { int o = __p.__offset(10); return o != 0 ? __p.bb.GetFloat(__p.__vector(o) + j * 4) : (float)0; }
  public int KernelScaleLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<float> GetKernelScaleBytes() { return __p.__vector_as_span<float>(10, 4); }
#else
  public ArraySegment<byte>? GetKernelScaleBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public float[] GetKernelScaleArray() { return __p.__vector_as_array<float>(10); }
  public ZivaRT.MatrixXi8? KernelCenters { get { int o = __p.__offset(12); return o != 0 ? (ZivaRT.MatrixXi8?)(new ZivaRT.MatrixXi8()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public float ScalePerKernel(int j) { int o = __p.__offset(14); return o != 0 ? __p.bb.GetFloat(__p.__vector(o) + j * 4) : (float)0; }
  public int ScalePerKernelLength { get { int o = __p.__offset(14); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<float> GetScalePerKernelBytes() { return __p.__vector_as_span<float>(14, 4); }
#else
  public ArraySegment<byte>? GetScalePerKernelBytes() { return __p.__vector_as_arraysegment(14); }
#endif
  public float[] GetScalePerKernelArray() { return __p.__vector_as_array<float>(14); }
  public ZivaRT.MatrixXi16? RbfCoeffs { get { int o = __p.__offset(16); return o != 0 ? (ZivaRT.MatrixXi16?)(new ZivaRT.MatrixXi16()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public float ScalePerRbfCoeff(int j) { int o = __p.__offset(18); return o != 0 ? __p.bb.GetFloat(__p.__vector(o) + j * 4) : (float)0; }
  public int ScalePerRbfCoeffLength { get { int o = __p.__offset(18); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<float> GetScalePerRbfCoeffBytes() { return __p.__vector_as_span<float>(18, 4); }
#else
  public ArraySegment<byte>? GetScalePerRbfCoeffBytes() { return __p.__vector_as_arraysegment(18); }
#endif
  public float[] GetScalePerRbfCoeffArray() { return __p.__vector_as_array<float>(18); }
  public ZivaRT.MatrixXi8? ReducedBasis { get { int o = __p.__offset(20); return o != 0 ? (ZivaRT.MatrixXi8?)(new ZivaRT.MatrixXi8()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public float ScalePerVertex(int j) { int o = __p.__offset(22); return o != 0 ? __p.bb.GetFloat(__p.__vector(o) + j * 4) : (float)0; }
  public int ScalePerVertexLength { get { int o = __p.__offset(22); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<float> GetScalePerVertexBytes() { return __p.__vector_as_span<float>(22, 4); }
#else
  public ArraySegment<byte>? GetScalePerVertexBytes() { return __p.__vector_as_arraysegment(22); }
#endif
  public float[] GetScalePerVertexArray() { return __p.__vector_as_array<float>(22); }
  /// list of vertices/scalars that this network influences
  public uint Outputs(int j) { int o = __p.__offset(24); return o != 0 ? __p.bb.GetUint(__p.__vector(o) + j * 4) : (uint)0; }
  public int OutputsLength { get { int o = __p.__offset(24); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<uint> GetOutputsBytes() { return __p.__vector_as_span<uint>(24, 4); }
#else
  public ArraySegment<byte>? GetOutputsBytes() { return __p.__vector_as_arraysegment(24); }
#endif
  public uint[] GetOutputsArray() { return __p.__vector_as_array<uint>(24); }

  public static Offset<ZivaRT.Network> CreateNetwork(FlatBufferBuilder builder,
      VectorOffset pose_indicesOffset = default(VectorOffset),
      VectorOffset pose_shiftOffset = default(VectorOffset),
      VectorOffset pose_scaleOffset = default(VectorOffset),
      VectorOffset kernel_scaleOffset = default(VectorOffset),
      Offset<ZivaRT.MatrixXi8> kernel_centersOffset = default(Offset<ZivaRT.MatrixXi8>),
      VectorOffset scale_per_kernelOffset = default(VectorOffset),
      Offset<ZivaRT.MatrixXi16> rbf_coeffsOffset = default(Offset<ZivaRT.MatrixXi16>),
      VectorOffset scale_per_rbf_coeffOffset = default(VectorOffset),
      Offset<ZivaRT.MatrixXi8> reduced_basisOffset = default(Offset<ZivaRT.MatrixXi8>),
      VectorOffset scale_per_vertexOffset = default(VectorOffset),
      VectorOffset outputsOffset = default(VectorOffset)) {
    builder.StartTable(11);
    Network.AddOutputs(builder, outputsOffset);
    Network.AddScalePerVertex(builder, scale_per_vertexOffset);
    Network.AddReducedBasis(builder, reduced_basisOffset);
    Network.AddScalePerRbfCoeff(builder, scale_per_rbf_coeffOffset);
    Network.AddRbfCoeffs(builder, rbf_coeffsOffset);
    Network.AddScalePerKernel(builder, scale_per_kernelOffset);
    Network.AddKernelCenters(builder, kernel_centersOffset);
    Network.AddKernelScale(builder, kernel_scaleOffset);
    Network.AddPoseScale(builder, pose_scaleOffset);
    Network.AddPoseShift(builder, pose_shiftOffset);
    Network.AddPoseIndices(builder, pose_indicesOffset);
    return Network.EndNetwork(builder);
  }

  public static void StartNetwork(FlatBufferBuilder builder) { builder.StartTable(11); }
  public static void AddPoseIndices(FlatBufferBuilder builder, VectorOffset poseIndicesOffset) { builder.AddOffset(0, poseIndicesOffset.Value, 0); }
  public static VectorOffset CreatePoseIndicesVector(FlatBufferBuilder builder, ushort[] data) { builder.StartVector(2, data.Length, 2); for (int i = data.Length - 1; i >= 0; i--) builder.AddUshort(data[i]); return builder.EndVector(); }
  public static VectorOffset CreatePoseIndicesVectorBlock(FlatBufferBuilder builder, ushort[] data) { builder.StartVector(2, data.Length, 2); builder.Add(data); return builder.EndVector(); }
  public static void StartPoseIndicesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(2, numElems, 2); }
  public static void AddPoseShift(FlatBufferBuilder builder, VectorOffset poseShiftOffset) { builder.AddOffset(1, poseShiftOffset.Value, 0); }
  public static VectorOffset CreatePoseShiftVector(FlatBufferBuilder builder, float[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddFloat(data[i]); return builder.EndVector(); }
  public static VectorOffset CreatePoseShiftVectorBlock(FlatBufferBuilder builder, float[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartPoseShiftVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddPoseScale(FlatBufferBuilder builder, VectorOffset poseScaleOffset) { builder.AddOffset(2, poseScaleOffset.Value, 0); }
  public static VectorOffset CreatePoseScaleVector(FlatBufferBuilder builder, float[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddFloat(data[i]); return builder.EndVector(); }
  public static VectorOffset CreatePoseScaleVectorBlock(FlatBufferBuilder builder, float[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartPoseScaleVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddKernelScale(FlatBufferBuilder builder, VectorOffset kernelScaleOffset) { builder.AddOffset(3, kernelScaleOffset.Value, 0); }
  public static VectorOffset CreateKernelScaleVector(FlatBufferBuilder builder, float[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddFloat(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateKernelScaleVectorBlock(FlatBufferBuilder builder, float[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartKernelScaleVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddKernelCenters(FlatBufferBuilder builder, Offset<ZivaRT.MatrixXi8> kernelCentersOffset) { builder.AddOffset(4, kernelCentersOffset.Value, 0); }
  public static void AddScalePerKernel(FlatBufferBuilder builder, VectorOffset scalePerKernelOffset) { builder.AddOffset(5, scalePerKernelOffset.Value, 0); }
  public static VectorOffset CreateScalePerKernelVector(FlatBufferBuilder builder, float[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddFloat(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateScalePerKernelVectorBlock(FlatBufferBuilder builder, float[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartScalePerKernelVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddRbfCoeffs(FlatBufferBuilder builder, Offset<ZivaRT.MatrixXi16> rbfCoeffsOffset) { builder.AddOffset(6, rbfCoeffsOffset.Value, 0); }
  public static void AddScalePerRbfCoeff(FlatBufferBuilder builder, VectorOffset scalePerRbfCoeffOffset) { builder.AddOffset(7, scalePerRbfCoeffOffset.Value, 0); }
  public static VectorOffset CreateScalePerRbfCoeffVector(FlatBufferBuilder builder, float[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddFloat(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateScalePerRbfCoeffVectorBlock(FlatBufferBuilder builder, float[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartScalePerRbfCoeffVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddReducedBasis(FlatBufferBuilder builder, Offset<ZivaRT.MatrixXi8> reducedBasisOffset) { builder.AddOffset(8, reducedBasisOffset.Value, 0); }
  public static void AddScalePerVertex(FlatBufferBuilder builder, VectorOffset scalePerVertexOffset) { builder.AddOffset(9, scalePerVertexOffset.Value, 0); }
  public static VectorOffset CreateScalePerVertexVector(FlatBufferBuilder builder, float[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddFloat(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateScalePerVertexVectorBlock(FlatBufferBuilder builder, float[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartScalePerVertexVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddOutputs(FlatBufferBuilder builder, VectorOffset outputsOffset) { builder.AddOffset(10, outputsOffset.Value, 0); }
  public static VectorOffset CreateOutputsVector(FlatBufferBuilder builder, uint[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddUint(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateOutputsVectorBlock(FlatBufferBuilder builder, uint[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartOutputsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<ZivaRT.Network> EndNetwork(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<ZivaRT.Network>(o);
  }
};


}
